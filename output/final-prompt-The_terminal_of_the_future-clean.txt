角色定位：Hacker News 洞察家与社区编辑

你是一名资深的科技编辑，尤其擅长在 Hacker News (HN) 这样高密度、高信噪比的开发者社区中“淘金”。你的读者是那些对技术趋势充满好奇，但没有时间（或精力）去爬完几百条英文评论的中文科技爱好者。

你的核心价值在于“过滤噪音，提炼精华”。你不仅仅是翻译或搬运评论，更是整场讨论的“策展人”和“首席评论员”。

你的工作是将一场（可能混乱的）HN 讨论，重组并转述为一篇结构清晰、逻辑连贯、充满洞见的中文博文。你要精准地捕捉到讨论中的核心议题、关键分歧、最有价值的个人见解（Ancedotes）以及技术的微妙之处，让读者在短时间内高效吸收整个社区的集体智慧。

工作流程：从 HN 讨论到洞察博文

当你收到一个 HN 讨论的链接或内容时，你将严格遵循以下步骤：

第一步：理解上下文（关键步骤）

1. 分析讨论主题：首先，查看 HN 帖子的标题。它通常会链接到一个外部文章、产品官网或一个问题。
2. 补全核心上下文：
  * 你必须首先使用 Google Search 工具，根据 HN 标题或讨论中的高频词汇，尽力去查找并阅读那个被讨论的“原始文章”或“原始主题”。
  * 如果没有这个原始文章作为“靶子”，评论就无从谈起。如果检索失败或上下文极其模糊，你必须立即停止，并向用户请求提供那个关键的“原始链接”或“原文内容”。
  * （例如：如果 HN 正在讨论“FooBar v2.0 发布”，你必须先搞清楚 FooBar v2.0 是什么，新特性有哪些。）
3. 明确讨论焦点：只有理解了“大家在聊什么”，你才能开始下一步。

第二步：筛选与归类（“淘金”）

1. 快速扫描（Filter）：通读所有（或高赞）评论，在内部思考中快速给它们打上标签。你的目标是过滤掉“+1”、“哈哈”、“跑题了”之类的噪音。
2. 识别高价值评论：重点寻找以下几类“金矿”：
  * 深刻洞见（Insight）：提供了新颖视角或指出了问题本质的评论。
  * 一线经验（Anecdote）：来自资深从业者的真实故事、失败教训或成功案例。
  * 激烈交锋（Debate）：正反双方有理有据的观点碰撞。
  * 技术细节（Details）：提供了被讨论主题（如某个工具）的隐藏用法或关键实现细节。
  * 主流共识（Consensus）：大多数高赞评论都同意的某个观点。

第三步：提炼与重组（“织锦”）

1. 寻找主线：不要逐条罗列评论。相反，你要从筛选出的“金矿”中，提炼出 2-4 个核心的议题（Themes）。
  * （例如：一场关于新数据库的讨论，主线可能是：1. 性能吹嘘与现实的差距；2. 它与 Postgres 的真正区别；3. 创始人这次的“黑历史”是否可信。）
2. 构建大纲：将筛选出的高价值评论，分别“填充”到你提炼的这几个核心议题之下，形成你博文的写作大纲。

第四步：撰写洞察博文（输出）

- 完全代入你的“角色定位”与“写作风格”，撰写一篇独立、完整的博文。
- 篇幅不限，以“把这场讨论的精华讲透”为唯一标准。

写作风格与技巧

- 读者导向：始终牢记你的读者是“想看热闹也想看门道的中文爱好者”。
- 通俗易懂：HN 评论区的术语密度可能比原文还高。你的首要任务是“翻译”它们。
  * （例：“作者提的‘RAG 幻觉’，大白话就是，AI 在回答时‘串供’了，把从A文档看来的事实张冠李戴到了B文档上。”）
- 结构化叙事（关键）：
  * 开篇破题：快速告诉读者“今天 HN 吵翻了，起因是 X 公司的 Y 产品”。先用一两句话介绍清楚那个“原始主题”（你在第一步检索到的内容）。
  * 善用小标题：必须使用小标题来组织文章。每个小标题对应你在第三步提炼的一个“核心议题”。（例如：“焦点一：这真的是‘性能杀手’吗？”、“争议点：创始人的回复为何激怒了社区？”、“一个‘老兵’的实战经验分享”）
- 转述而非直译：
  * 不要生硬地引用：“用户A说……用户B反驳说……”。
  * 要用你自己的话，将评论的观点“编织”进你的叙述中。
  * （例：“关于性能问题，社区的观点基本分成了两派。一派认为官方数据水分太大，有位自称测试过的工程师就指出……；而另一派则辩护说，这种架构在特定场景下（比如……）确实有奇效。”）
- 点明“隐藏信息”：
  * HN 讨论经常有“行话”或“黑话”（比如对某些公司或大佬的昵称）。你要在转述时自然地解释背景，帮读者看懂“梗”。
- 结尾总结：
  * 在文章最后，给出一个清晰的“Takeaway”。这场讨论最终得出了什么有价值的共识？或者，最大的分歧点在哪？给读者一个“全貌”总结。

禁止出现的表达方式

- 避免生硬的引导语，如“本文总结了 HN 的讨论……”、“以下是一些精彩评论：”。
- 避免大段落的“用户A说：[引用]”、“用户B说：[引用]”的枯燥罗列。
- 绝对禁止在未获取“原始主题”上下文（第一步）的情况下，就开始盲目地总结评论。

## HN讨论内容

[
  {
    "type": "story",
    "by": "miguelraz",
    "title": "The terminal of the future",
    "url": "https://jyn.dev/the-terminal-of-the-future",
    "time": 1762891893
  },
  {
    "type": "comment",
    "by": "wredcoll",
    "text": "The terminal of the future is called a web browser.",
    "time": 1762896460
  },
  {
    "type": "comment",
    "by": "add-sub-mul-div",
    "text": "That would be quite an own goal, to invite an extra middleman into the mix. Especially when so many people will go the path of least resistance and use a tech giant product as that middleman.",
    "time": 1762897233
  },
  {
    "type": "comment",
    "by": "wredcoll",
    "text": "I mean, what is a terminal emulator? It&#x27;s a program that displays the output of other programs &quot;inside&quot; it.<p>Terminal emulators display grids of characters using all sorts of horrifying protocols.<p>Web browsers display html generated by other programs.",
    "time": 1762897685
  },
  {
    "type": "comment",
    "by": "shirro",
    "text": "It could have been. The platform got taken over by a very different culture and has tended to serve different purposes.<p>The web solves problems that are almost impossible to properly solve with a terminal, particularly with rendering of more complicated languages and display and interaction with sophisticated visualisations.<p>Pushing the terminal further while maintaining compatibility, performance and avoiding a terminal war with incompatible protocols is going to be a struggle.",
    "time": 1762897991
  },
  {
    "type": "comment",
    "by": "xixixao",
    "text": "This might be useful (maybe) to the author: I am in a group (probably small, but I don’t think negligeble) that gave up on Warp because it doesn’t support standard or custom command completions [0]<p>Some lesson must surely be drawn from this about incremental adoption.<p>[0] <a href=\"https:&#x2F;&#x2F;github.com&#x2F;warpdotdev&#x2F;Warp&#x2F;issues&#x2F;1811\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;warpdotdev&#x2F;Warp&#x2F;issues&#x2F;1811</a>",
    "time": 1762898150
  },
  {
    "type": "comment",
    "by": "hastamelo",
    "text": "opened on the chatgpt page",
    "time": 1762898179
  },
  {
    "type": "comment",
    "by": "zadjii",
    "text": "Y&#x27;know, I spent a week investigating doing something similar with the Windows Terminal about 18 months ago: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;terminal&#x2F;issues&#x2F;16495#issuecomment-1984745678\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;terminal&#x2F;issues&#x2F;16495#issuecomm...</a><p>There&#x27;s even more under the &quot;Updates archive&quot; expando in that post.<p>It was a pretty compelling prototype. But after I played with Polyglot Notebooks[1], I pretty much just abandoned that experiment. There&#x27;s a _lot_ of UI that needs to be written to build a notebook-like experience. But the Polyglot notebooks took care of that by just converting the commandline backend to a jupyter kernel.<p>I&#x27;ve been writing more and more script-like experiments in those ever since. Just seems so much more natural to have a big-ol doc full of notes, that just so happens to also have play buttons to Do The Thing.<p>[1]: <a href=\"https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=ms-dotnettools.dotnet-interactive-vscode\" rel=\"nofollow\">https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=ms-dotne...</a>",
    "time": 1762898322
  },
  {
    "type": "comment",
    "by": "shellkr",
    "text": "This I am afraid does not feel as the right thing to do. I think the KISS-principle is a good standard to follow and while terminals have to do more than one thing, it should not do everything. Complexity leads to instability. Terminals has to be nimble and not clumsy behemoths like web browsers.",
    "time": 1762898550
  },
  {
    "type": "comment",
    "by": "jynelson",
    "text": "yeah! so i somehow forgot to include this in the post, but one of the thing i would want as part of this is tab complete that integrates with the shell, essentially it would make an RPC call (in the step 3 sense). there’s things that work like this already today, they’re just extremely cursed ^^ but that’s never stopped me before. <a href=\"https:&#x2F;&#x2F;github.com&#x2F;Aloxaf&#x2F;fzf-tab?tab=readme-ov-file#difference-from-other-plugins\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;Aloxaf&#x2F;fzf-tab?tab=readme-ov-file#differe...</a>",
    "time": 1762898679
  },
  {
    "type": "comment",
    "by": "zazaulola",
    "text": "What do you mean by “terminal”? Perhaps you are referring to something like a VT100.<p><a href=\"https:&#x2F;&#x2F;commons.wikimedia.org&#x2F;wiki&#x2F;File:DEC_VT100_terminal.jpg#&#x2F;media&#x2F;File:DEC_VT100_terminal.jpg\" rel=\"nofollow\">https:&#x2F;&#x2F;commons.wikimedia.org&#x2F;wiki&#x2F;File:DEC_VT100_terminal.j...</a><p>I may disappoint you with the fact that IBM PC-compatible computers have replaced devices of that class. We can only observe certain terminal emulators in some operating systems. There have been many attempts to expand the functionality of these emulators. However, most features beyond the capabilities of VT100 have not caught on (except UTF-8 support). I do not believe that anything will change in the foreseeable future.",
    "time": 1762898822
  },
  {
    "type": "comment",
    "by": "cpendery",
    "text": "interesting post! shell integration has gotten a lot better since the new ConPTY on windows doesn’t strip OSC sequences &amp; send them ahead of the text",
    "time": 1762899004
  },
  {
    "type": "comment",
    "by": "skydhash",
    "text": "I read the whole thing and at first glance, it seems like a whole NIH list of wishes. We already have alternatives to the terminal, but the article have no mentions of them:<p>- Emacs (inherited from lisp machines?). A VM which is powered by lisp. The latter make it easy to redefine function, and commands are just annotated functions. As for output, we have the buffer, which can be displayed in windows, which are arranged in a tiling manner in a frame. And you can have several frames. As the buffer in a window as the same grid like basis as the terminal emulator, we can use cli as is, including like a terminal emulator (vterm, eat, ansi-term,...). You can eschew the terminal flow and use the REPL flow instead (shell-mode, eshell,...). There&#x27;s support for graphics, but not a full 2d context.<p>- Acme: Kinda similar to emacs, but the whole thing is mostly about interactive text. Meaning any text can be a command. We also have the tiling&#x2F;and stacking windows things that displays those texts.<p>I would add Smalltalk to that, but it&#x27;s more of an IDE than a full computing environment. But to extend it to the latter would still be a lower effort than what is described in the article.",
    "time": 1762899661
  },
  {
    "type": "comment",
    "by": "thatcherc",
    "text": "I appreciated the Pluto.jl mention!  Going from Pluto notebooks that understand data flow to Jupyter notebooks where you have to tell the computer which order to run the cells in is always baffling to me. Why doesn&#x27;t Jupyter know the run order and dependencies already? The way Pluto handles dependencies between code cells is really just so nice.",
    "time": 1762899695
  },
  {
    "type": "comment",
    "by": "Etheryte",
    "text": "Terminals are far from simple, that&#x27;s the whole problem. We carry the weight of decades of technical constraints and arbitrary decisions on our shoulders every time we fire up a terminal emulator.",
    "time": 1762899968
  },
  {
    "type": "comment",
    "by": "walterlw",
    "text": "If you haven&#x27;t yet do check out Marimo<p>[0] <a href=\"https:&#x2F;&#x2F;marimo.io&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;marimo.io&#x2F;</a>",
    "time": 1762900442
  },
  {
    "type": "comment",
    "by": "jynelson",
    "text": "i would describe the main idea of the post as <i>opening up the data model</i> of the terminal. the list of wishes are an example of things you can build once you&#x27;ve done that, not the primary reason that opening the data model is useful.",
    "time": 1762900509
  },
  {
    "type": "comment",
    "by": "wrs",
    "text": "Re &quot;stage 2: persistent sessions&quot;, iTerm2 already does this. The PTYs are owned by background processes independent of the GUI application. So iTerm2 can upgrade the application without interrupting the running terminal sessions.",
    "time": 1762901079
  },
  {
    "type": "comment",
    "by": "jynelson",
    "text": "this is really cool omg! i didn&#x27;t know that, i&#x27;ll do some research.<p>one of the strange things to me about the terminal landscape is how little knowledge sharing there is compared to other domains i&#x27;m familiar with. iTerm has a bunch of things no one else has; kitty influenced wezterm but otherwise no one else seems to have valued reflection; there&#x27;s a whole bunch of extensions to ANSI escapes but most of them are non-standard and mutually incompatible. it&#x27;s weird. if i compare to something like build systems, there&#x27;s a lot more cross-pollination of ideas there.",
    "time": 1762901646
  },
  {
    "type": "comment",
    "by": "joshu",
    "text": "lots of terminals these days support imgcat and i rely on it heavily: <a href=\"https:&#x2F;&#x2F;iterm2.com&#x2F;documentation-images.html\" rel=\"nofollow\">https:&#x2F;&#x2F;iterm2.com&#x2F;documentation-images.html</a>",
    "time": 1762901897
  },
  {
    "type": "comment",
    "by": "unixplumber",
    "text": "&gt; Terminal emulators display grids of characters using all sorts of horrifying protocols.<p>What sort of &quot;horrifying protocols&quot;? The entire VT220 state machine diagram can be printed on a single letter- or A4-sized sheet of paper. That&#x27;s the complete &quot;protocol&quot; of that particular terminal (and of any emulator of it). Implementing the VT220 with a few small extensions (e.g., 256 colors or 24-bit colors) wouldn&#x27;t be too onerous. I implemented such a parser myself in probably a few hundred lines of code, plus a bit more to do all of the rendering (drawing glyphs directly to a bitmapped display, with no libraries) and handling user input from a keyboard. You&#x27;d have a difficult time properly parsing and rendering a significant subset of HTML in less than a few _thousand_ lines of code.<p>Edit to add: terminal emulators often implement other terminals like VT420, but the VT220 is enough for the vast majority of terminal needs.",
    "time": 1762902140
  },
  {
    "type": "comment",
    "by": "shellkr",
    "text": "I am all for removing old junk but not that it should be replaced with newer junk.",
    "time": 1762902217
  },
  {
    "type": "comment",
    "by": "thomasahle",
    "text": "I expected this to be about some &quot;AI first&quot; terminal. But the article doesn&#x27;t mention AI at all, for better or worse...",
    "time": 1762902229
  },
  {
    "type": "comment",
    "by": "cb321",
    "text": "Any article about this topic that does not at least mention <a href=\"https:&#x2F;&#x2F;arcan-fe.com&#x2F;about&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;arcan-fe.com&#x2F;about&#x2F;</a> feels incomplete.  (Also, Arcan is already available.)",
    "time": 1762902780
  },
  {
    "type": "comment",
    "by": "mrandish",
    "text": "Yes, this was my first thought too. I haven&#x27;t used a hardware text terminal since the 80s so maybe I don&#x27;t get where the TFA is coming from? It starts out by stating <i>&quot;This post is part 6 of a multi-part series called &#x27;the computer of the next 200 years&#x27;&quot;.</i> Given that context, why is the focus on the evolution of 1980s VT100-type protocols?\nI&#x27;m at home and there are over a half dozen different devices within 25 ft which come standard with an HTML browser. Sure, modern browsers have some incompatibilities at the edges but if you&#x27;re in need of a multi-decade, platform agnostic, lingua franca then W3C minimal baseline HTML&#x2F;CSS + ECMAscript seems like the obvious winner (with no viable second place really).<p>Don&#x27;t get me wrong, I&#x27;d be quite interested in a vintage computing discussion on the evolution of VT-100&#x2F;220 etc terminal protocols. There were some interesting things done into the 90s. That&#x27;s actually what I clicked in expecting. Of course, those were all supplanted by either XWindows (which I never got to use much) or eventually HTML&#x2F;CSS. And if we&#x27;re talking more broadly about structured page description languages, there&#x27;s no shortage of alternatives from NAPLPS to Display Postscript.",
    "time": 1762902806
  },
  {
    "type": "comment",
    "by": "imiric",
    "text": "I dread reading these articles written by people who perceive the command-line interface &#x2F; terminal &#x2F; shell to be this archaic system, and propose &quot;modernizing&quot; it by cramming whatever UI&#x2F;UX they&#x27;re most familiar with.<p>The last thing a command-line terminal needs is a Jupyter Notebook-like UI. It doesn&#x27;t need to render HTML; it doesn&#x27;t need rerun and undo&#x2F;redo; and it <i>definitely</i> doesn&#x27;t need structured RPC. Many of the mentioned features are already supported by various tooling, yet the author dismisses them because... bugs?<p>Yes, terminal emulators and shells have a lot of historical baggage that we may consider weird or clunky by today&#x27;s standards. But many design decisions made 40 years ago are directly related to why some software has stood the test of time, and why we still use it today.<p>&quot;Modernizing&quot; this usually comes with very high maintenance or compatibility costs. So, let&#x27;s say you want structured data exchange between programs ala PowerShell, Nushell, etc. Great, now you just need to build and maintain shims for every tool in existence, force your users to use your own custom tools that support these features, and ensure that everything interoperates smoothly. So now instead of creating an open standard that everyone can build within and around of, you&#x27;ve built a closed ecosystem that has to be maintained centrally. And yet the &quot;archaic&quot; unstructured data approach is what allows me to write a script with tools written decades ago interoperating seamlessly with tools written today, without either tool needing to directly support the other, or the shell and terminal needing to be aware of this. It all just works.<p>I&#x27;m not saying that this ecosystem couldn&#x27;t be improved. But it needs broad community discussion, planning, and support, and not a brain dump from someone who feels inspired by Jupyter Notebooks.",
    "time": 1762902832
  },
  {
    "type": "comment",
    "by": "kloud",
    "text": "Great thought provoking article! Indeed, typing commands on the command line feels primitive like typing code into interactive interpreters (python, irb, etc.). Those are primitive REPLs.<p>With lisp REPLs one types in the IDE&#x2F;editor having full highlighting, completions and code intelligence. Then code is sent to REPL process for evaluation. For example Clojure has great REPL tooling.<p>A variation of REPL is the REBL (Read-Eval-Browse Loop) concept, where instead of the output being simply printed as text, it is treated as values that can be visualized and browsed using graphical viewers.<p>Existing editors can already cover the runbooks use case pretty well. Those can be just markdown files with key bindings to send code blocks to shell process for evaluation. It works great with instructions in markdown READMEs.<p>The main missing feature editor-centric command like workflow I can imagine is the history search. It could be interesting to see if it would be enough to add shell history as a completion source. Or perhaps have shell LSP server to provide history and other completions that could work across editors?",
    "time": 1762903246
  },
  {
    "type": "comment",
    "by": "jynelson",
    "text": "whoa this looks fascinating, i&#x27;ve never heard of it before! thank you for the link :)",
    "time": 1762903465
  },
  {
    "type": "comment",
    "by": "jynelson",
    "text": "&gt; Great, now you just need to build and maintain shims for every tool in existence, force your users to use your own custom tools that support these features, and ensure that everything interoperates smoothly.<p>Yes, this is the work. <a href=\"https:&#x2F;&#x2F;becca.ooo&#x2F;blog&#x2F;vertical-integration&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;becca.ooo&#x2F;blog&#x2F;vertical-integration&#x2F;</a>",
    "time": 1762903554
  },
  {
    "type": "comment",
    "by": "art-w",
    "text": "Two interesting projects in that space:<p>- <a href=\"https:&#x2F;&#x2F;arcan-fe.com&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;arcan-fe.com&#x2F;</a> which introduces a new protocol for TUI applications, which leads to better interactions across the different layers (hard to describe! but the website has nice videos and explanations of what is made possible)<p>- Shelter, a shell with reproducible operations and git-like branches of the filesystem <a href=\"https:&#x2F;&#x2F;patrick.sirref.org&#x2F;shelter&#x2F;index.xml\" rel=\"nofollow\">https:&#x2F;&#x2F;patrick.sirref.org&#x2F;shelter&#x2F;index.xml</a>",
    "time": 1762903635
  },
  {
    "type": "comment",
    "by": "spudlyo",
    "text": "Emacs also has Org-mode and org-babel, which can work a lot like a Jupyter notebook, and can even talk to jupyter kernels. I do a <i>lot</i> in Emacs, especially now that I&#x27;m comfortable with GPTel.<p>I open a poorly aligned, pixelated PDF scan of a 100+ year old Latin textbook in Emacs, mark a start page, end page, and Emacs lisp code shells out to qpdf to create a new smaller pdf from my page range to &#x2F;tmp, and then adds the resulting PDF to my LLM context. Then my code calls gptel-request with a custom prompt and I get an async elisp callback with the OCR&#x27;d PDF now in Emacs&#x27; org-mode format, complete with italics, bold, nicely formatted tables, and with all the right macrons over the vowels, which I toss into a scratch buffer. Now that the chapter from my textbook in a markup format, I can select a word, immediately pop up a Latin-to-English dictionary entry or select a whole sentence to hand to an LLM to analyze with a full grammatical breakdown while I&#x27;m doing my homework exercises. This 1970s vintage text editor is also a futuristic language learning platform, it blows my mind.",
    "time": 1762903643
  },
  {
    "type": "comment",
    "by": "ellieh",
    "text": "&gt; It could be interesting to see if it would be enough to add shell history as a completion source.<p>Atuin runbooks (mentioned in the article) do this! Pretty much anywhere we allow users to start typing a shell command we feed shell history into the editor",
    "time": 1762903706
  },
  {
    "type": "comment",
    "by": "hamasho",
    "text": "I tried to find a terminal which can shows images, videos, and other media. I know it&#x27;s not a UNIX way, but sometimes it can help. There are multiple options, but they didn&#x27;t click in me.<p>But just showing a browser like Jupyter would be very useful. It can handle a wide variety of media, can easily show JS heavy webpages unlike curl, and with text option to show text based result like w3m but can handle JS, it will be more useful.<p><pre><code>  browser google.com&#x2F;maps  # show google map and use interactively\n  browser google.com&#x2F;search?q=cat&amp;udm=2  # show google image result\n  browser --text jsheavy.com | grep -C 10 keyword   # show content around keyword but can handle JS\n  vim =(browser --text news.ycombinator.com&#x2F;item?id=45890186)  # show Hacker News article and can edit text result directly)</code></pre>",
    "time": 1762903861
  },
  {
    "type": "comment",
    "by": "hombre_fatal",
    "text": "Nonsense. It&#x27;s just some person brainstorming improvements. You shouldn&#x27;t need &quot;broad community discussion&quot; every time you toy with some ideas.",
    "time": 1762904124
  },
  {
    "type": "comment",
    "by": "skissane",
    "text": "My personal opinion-psuedoterminals should be enhanced to provide some mechanism for sending out-of-band data, like the existing TIOCPKT but on steroids. Maybe something like… if both ends support it, they can exchange JSON-RPC messages over this out-of-band channel, with it being possible to discover if the other side supports this or not. Possibly this is just a new TIOC* ioctl<p>Why? Well one reason is escape sequences are really limited and messy. This would enable everyone to gradually and backward-compatibly transition to a more modern alternative. Once you have a JSON-RPC channel, the two ends can use it to negotiate what specific features they support. It would be leveraging patterns already popular with LSP, MCP, etc. And it would be mostly in userspace, only a small kernel enhancement would be required (the kernel doesn’t have to actually understand these JSON-RPC messages just offer a side channel to convey them).<p>I suppose you could do it without any kernel change if you just put a Unix domain socket in an environment variable: but that would be more fragile, some process will end up with your pty but missing the environment variable or vice versa<p>Actually I’d add this out-of-band JSON-RPC feature to pipes too, so if I run “foo | bar”, foo and bar can potentially engage in content&#x2F;feature negotiation with each other",
    "time": 1762904350
  },
  {
    "type": "comment",
    "by": "zzo38computer",
    "text": "I had thought of a idea in a operating system design, which has many similarities to this but also many significant differences. The rest of the operating system would also be designed to support this, and the REPL would also be integrated with editors (like they show) and with a zoned spreadsheet. There would also be transactions (not the same as described there, but there is a similarity), and also capabilities (usable for security and many other things), and possibility to move objects between windows (this also allows it to work better with GUI; e.g. you can write a loop and use some combination of keys with mouse to drag a command button from a GUI window into your text in order to execute that command button within the loop; or you can copy data displayed in a table in another program in order to perform calculations on it or write a conversion to other format to then copy into another program, etc). However, tabs and panes would be handled by the window manager. However, it would use a binary format (a kind of TLV format), and it would not use CSS and HTML and Unicode. For rich text and other things there would also be a Reveal Codes function in order to reveal (and modify) the codes.",
    "time": 1762904635
  },
  {
    "type": "comment",
    "by": "zzo38computer",
    "text": "I think JSON would not be the good format for this; it is too limited and requires escaping. DER or SDSER might be a better format; numbers can be stored efficiently in binary, no escaping is needed, you can use any character set (not only Unicode), binary data can be stored directly (rather than needing to encode as hex or base64), etc.",
    "time": 1762904773
  },
  {
    "type": "comment",
    "by": "user3939382",
    "text": "I designed this months ago and 10x more but I’m going to release it in a bundle",
    "time": 1762905038
  },
  {
    "type": "comment",
    "by": "skissane",
    "text": "If one were adding this to the kernel, maybe rather than stipulating a specific protocol, assign them magic numbers; maybe JSON-RPC could be protocol 0x4a534f4e. An app could ask the kernel “which protocols does the pty master support?”, and get back a list of integers. And then it could ask to open a sidechannel for protocol 0x4a534f4e. So the kernel doesn’t even have to get in the business of mandating a specific protocol (whether JSON-RPC or CBOR or 0MQ or whatever), it just opens side channels with a meaningless (to the kernel) integer to identify its protocol.",
    "time": 1762905455
  },
  {
    "type": "comment",
    "by": "zzo38computer",
    "text": "I think that might work OK.<p>Passing the process ID and user ID might be helpful to improve security of the terminal emulator, too. If the sidechannel is a UNIX socket then it will do this (with SCM_CREDENTIALS), as well as pass file descriptors (with SCM_RIGHTS).",
    "time": 1762906475
  },
  {
    "type": "comment",
    "by": "nixpulvis",
    "text": "I also have lots of ideas, not all that different from the goals of some of these... but there&#x27;s something critical to remember. The terminal survives as it is, because so many tools were built to run on them. They are only becoming more cross platform and feature rich, albeit slowly and conservatively.<p>Maintaining a high level of backwards compatibility while improving the user experience is critical. Or at least to me. For example, my #1 fristration with neovim, is the change to ! not just swapping the alt screen back to the default and letting me see and run what I was doing outside of it.<p>We generally like the terminal because, unlike GUIs it&#x27;s super easy to turn a workflow into a script, a manual process into an automated process. Everything is reproducible, and everything is ripgrep-able. It&#x27;s all right there at your fingertips.<p>I fell in love with computers twice, once when I got my first one, and again when I learned to use the terminal.",
    "time": 1762908229
  },
  {
    "type": "comment",
    "by": "epage",
    "text": "&gt; It does this using (mostly) standard features built-in to the terminal and shell (a custom DCS): you can read their explanation here. It&#x27;s possible to do this less invasively using OSC 133 escape codes; I&#x27;m not sure why Warp didn&#x27;t do this, but that&#x27;s ok.<p>Independent of the rest, I would love for more terminal emulators to support OSC 133.",
    "time": 1762908531
  },
  {
    "type": "comment",
    "by": "jynelson",
    "text": "omg i&#x27;ve wanted something like shelter for literal years<p>it &quot;cheats&quot; a little because it requires the underlying filesystem to support snapshots but it&#x27;s still really really cool, thank you for the link!",
    "time": 1762909271
  },
  {
    "type": "comment",
    "by": "robot-wrangler",
    "text": "I think the modern unix&#x27;y thing to do here is always send all messages intended for the user to stderr (regardless of whether they are actually errors), and <i>always</i> respond with machine-friendly JSON on stdout by default.  AFAIK there&#x27;s no downsides to this.. you can still have color on stderr, you can still draw sixel pictures or whatever.  Meanwhile pipes and redirection still work as expected.<p>No need for content&#x2F;feature negotiations.. machine readable just defaults to JSON unless there&#x27;s a --format flag for something else.  And if you add that on the generation-side of the pipe, you just need to remember to put it on the consumer-side.",
    "time": 1762909652
  },
  {
    "type": "comment",
    "by": "alwillis",
    "text": "<i>pushing the terminal further while maintaining compatibility, performance and avoiding a terminal war with incompatible protocols is going to be a struggle.</i><p>Unless someone creates a cross-platform, open source, modern and standards compliant terminal engine [1].<p>[1]: <a href=\"https:&#x2F;&#x2F;mitchellh.com&#x2F;writing&#x2F;libghostty-is-coming\" rel=\"nofollow\">https:&#x2F;&#x2F;mitchellh.com&#x2F;writing&#x2F;libghostty-is-coming</a>",
    "time": 1762910460
  },
  {
    "type": "comment",
    "by": "stevenjgarner",
    "text": "I cannot agree more.  The most perfect terminal of the future will be the terminal of today.  Leave it the heck alone.  Terminal Emulators (1984 for MacTerminal), Vi (1976 by Bill Joy then 1988 by Bram Moolenaar for Vi IMproved) and Emacs (1976 by David A. Moon and Guy L. Steele Jr. then 1984 for GNU Emacs by Richard Stallman) are extremely primordial ancient programs.  Among the oldest programs still in active use.  There is a reason for that.  During my evolution with technology, every time I wanted these programs to do something &quot;familiar&quot;, it was because of my own ignorance and lack of familiarity.  As I became familiar, I slowly realized that their power is in their simplicity.  Not everything needs to be improved.  &quot;There is more to life than speeding it up&quot; - Mahatma Gandhi",
    "time": 1762910763
  },
  {
    "type": "comment",
    "by": "krautburglar",
    "text": "I wish people would stop back-porting new features into vt terms, since those “features” gradually leak into terminal programs, which start spewing garbage in older terminals at the next update. Instead of having a standard, we get <i>ESC[whatever-the-fuck-i-feel-like;</i>, but with vt220 characteristics.<p>Missing out on inline images and megabytes of true-color CSI codes is a feature, not a bug, when bandwidth is limited.<p>If you want jupyter, we have jupyter.  If you want HTML, we have several browsers.  If you want something else, make it, but please don’t use vt220 codes and call it a terminal.<p>The article is just wish-listing more NIH barbarism to break things with.  RedHat would hire this guy in a heartbeat.",
    "time": 1762912838
  },
  {
    "type": "comment",
    "by": "robot-wrangler",
    "text": "&gt; Acme:<p>Got a link to what you meant?  This is pretty hard to search for.<p>&gt; - Emacs<p>One thing in common with emacs, jupyter, vscode.. these are all capable platforms but not solutions, and if you want to replace your terminal emulator by building on top of them it&#x27;s doable but doesn&#x27;t feel very portable.<p>I&#x27;d challenge people that are making cool stuff to show it, and then ship it.  Not a pile of config + a constellation of plugins at undeclared versions + a &quot;simple&quot; 12-step process that would-be adopters must copy&#x2F;paste.  That&#x27;s <i>platform customization</i>, not something that feels like an application. Actually try bundling your cool hack as a docker container or a self-extracting executable of some kind so that it&#x27;s low-effort reproducible.",
    "time": 1762913052
  },
  {
    "type": "comment",
    "by": "hmokiguess",
    "text": "I have tried to like Jupyter but I can’t.<p>My biggest gripe with it is that it quickly ends up becoming an actual production workload, and it is not simple to “deploy” and “run” it in an ops way.<p>Lots of local&#x2F;project specific stuff like hardcoded machine paths from developers or implicit environments.<p>Yes, I know it can be done right, but it makes it sooooooooo easy to do it wrong.<p>I think I can’t not see it as some scratchpad for ad-hoc stuff.",
    "time": 1762913063
  },
  {
    "type": "comment",
    "by": "zzo38computer",
    "text": "There are many downsides.<p>There are problems with using JSON for this; other formats would be better. JSON needs escaping, cannot effectively transfer binary data (other than encoding as hex or base64), cannot use character sets other than Unicode, etc. People think JSON is good, but it isn&#x27;t.<p>Also, you might want to use less or other programs for the text output, which might be the primary output that you might also want to pipe to other programs, redirect to a file (or printer), etc. This text might be separate from the status messages (which would be sent to stderr; these status messages are not necessarily errors, although they might be). If you use --help deliberately then the help message is the primary message, not a status message.<p>(In a new operating system design it could be improved, but even then, JSON is not the format for this; a binary format would be better (possibly DER, or SDSER, which is a variant of DER that supports streaming, in a (in my opinion) better way than CER and BER does).)<p>(Another possibility might be to add another file descriptor for structured data, and then use an environment variable to indicate its presence. However, this just adds to the messiness of it a little bit, and requires a bit more work to use it with the standard command shells.)",
    "time": 1762913575
  },
  {
    "type": "comment",
    "by": "dacapoday",
    "text": "Why restrict it to Shell programs with script language? What about LLM powered chat? Terminal is the UI between humans and machines, future is IM App. What people do to each other, people and machines will do the same(ask,talk,chat,assign task).",
    "time": 1762913709
  },
  {
    "type": "comment",
    "by": "vacuity",
    "text": "Currently being discussed at <a href=\"https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=45891772\">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=45891772</a>",
    "time": 1762914127
  },
  {
    "type": "comment",
    "by": "vacuity",
    "text": "I think this will be like the Fish shell, where backwards compatibility is left to existing tools, but a fresh environment is available going forward.",
    "time": 1762914215
  },
  {
    "type": "comment",
    "by": "zrail",
    "text": "&gt; Got a link to what you meant? This is pretty hard to search for.<p>It&#x27;s part of plan9:<p><a href=\"https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Acme_(text_editor)\" rel=\"nofollow\">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Acme_(text_editor)</a>",
    "time": 1762914407
  },
  {
    "type": "comment",
    "by": "vacuity",
    "text": "By the way, have you started writing your OS?",
    "time": 1762914513
  },
  {
    "type": "comment",
    "by": "anon7725",
    "text": "I don’t know how you work, but I spend a good portion of my day in a terminal while working on AI-type projects.<p>The terminal never left.",
    "time": 1762914591
  },
  {
    "type": "comment",
    "by": "vacuity",
    "text": "I think standardizing a file descriptor interface would be ideal. It&#x27;s ridiculous that the file descriptors are exposed and densely packed. I wonder if a protocol could be made that demultiplexes for stderr and the new file descriptor could be made.",
    "time": 1762914915
  },
  {
    "type": "comment",
    "by": "robot-wrangler",
    "text": "I guess I don&#x27;t see those as big downsides because I don&#x27;t think people usually want binary data or quoted strings back from a CLI command, nor do they want column oriented output, nor &quot;user friendly&quot; tables.<p>Answering --help with JSON is a good example, how bad is it really if the response is JSON?  Well, using less works fine still and you can still grep if you want simple substring search.  Wanting a section is probably more common, so maybe you&#x27;d &quot;grep&quot; for a subcommand with `jq .subcommand` or an option with `jq .subcommand.option`, and maybe get yourself a fancier, JSON-friendly version of less that handles escaped quotes and newlines.  Tables and tab-or-space delimited output overflow char limits, force the command-generator to figure out character wrapping, and so on.  Now you need a library to generate CLI help properly, but if you&#x27;re going to have a library why not just spit JSON and decouple completely from display details to let the consumer handle it.<p>Structured output by default just makes sense for practically everything except `cat`.  And while your markdown files or csv files might have quoted strings, looking at the raw files isn&#x27;t something people really want from shells or editors.. they want something &quot;rendered&quot; in one way or another, for example with syntax highlighting.<p>Basically in 2025 neither humans <i>nor</i> machines benefit much from unstructured raw output.  Almost any CLI that does this needs to be paired with a parser (like <a href=\"https:&#x2F;&#x2F;github.com&#x2F;kellyjonbrazil&#x2F;jc\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;kellyjonbrazil&#x2F;jc</a>) and&#x2F;or a renderer (like <a href=\"https:&#x2F;&#x2F;github.com&#x2F;charmbracelet&#x2F;glow\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;charmbracelet&#x2F;glow</a>).  If no such pairing is available then it pushes many people to separately reinvent parsers badly.  JSON&#x27;s not perfect but (non-minified) it&#x27;s human-readable <i>enough</i> to address the basic issues here without jumping all the way towards binary or (shudder) HTML",
    "time": 1762915726
  },
  {
    "type": "comment",
    "by": "skydhash",
    "text": "&gt; Got a link to what you meant? This is pretty hard to search for.<p><a href=\"http:&#x2F;&#x2F;acme.cat-v.org&#x2F;\" rel=\"nofollow\">http:&#x2F;&#x2F;acme.cat-v.org&#x2F;</a><p><a href=\"http:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=dP1xVpMPn8M\" rel=\"nofollow\">http:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=dP1xVpMPn8M</a><p>&gt; *I&#x27;d challenge people that are making cool stuff to show it, and then ship it.<p>Emacs has the following builtin and more<p>- Org mode (with babel): Note taking and outliner, authoring, notebooks, agenda, task management, timetracking,...<p>- Eshell: A shell in lisp, similar to fish, but all the editor commands are available like cli tools.<p>- comint: All things REPL (sql client, python,...)<p>- shell-command and shell-mode: The first is for ad-hoc commands, the second is derived from comint and give you the shell in an REPL environment (no TUI).<p>- term: terminal emulator, when you really want a tui. But the support for escape sequences is limited, so you may want something like `eat` or `vterm`.<p>- compile: all things build tools. If you have something that report errors and where those errors are located in files, then you can tie it to compile and have fast navigation to those locations.<p>- flymake: Watch mode for the above. It lets you analyze the current file<p>- ispell and flyspell: Spell checking<p>- dired: file management<p>- grep: Use the output of $grep_like_tool for navigatoin<p>- gnus and rmail: Everything mail and newsgroup.<p>- proced: Like top<p>- docview: View pdf and ps files, although you can probably hack it to display more types.<p>- tramp: Edit files from anywhere...<p>And many more from utilities (calc, calendar) and games to low level functions (IPC, network,...) and full blown applications (debugger, MPD client). And a lot of stuff to write text and code thhings. All lisp code, with nice documentation. That&#x27;s just for the built-in stuff.<p>If not for the state of the Web, you could probably just went straight from init to Emacs.",
    "time": 1762915768
  },
  {
    "type": "comment",
    "by": "quasarj",
    "text": "For better, my friend",
    "time": 1762916050
  },
  {
    "type": "comment",
    "by": "zzo38computer",
    "text": "Structured output would be helpful in many ways, but JSON is not a good format for this (neither is YAML nor XML nor HTML).<p>&gt; JSON&#x27;s not perfect but (non-minified) it&#x27;s human-readable enough to address the basic issues here without jumping all the way towards binary or (shudder) HTML<p>It does not address most of the real issues. Programs that deal with pictures, sounds, non-Unicode text, structures of the kinds that JSON does not have, etc, will not do as well; and the input&#x2F;output will involve converting escaping. (One format that I think is better is DER, although, it is binary format. I did write a program to convert JSON to DER, though.)",
    "time": 1762916459
  },
  {
    "type": "comment",
    "by": "sleepybrett",
    "text": "one of the things that kinda petered out but was really interesting was xiki, kinda a precursor to some of this stuff.",
    "time": 1762917653
  },
  {
    "type": "comment",
    "by": "robot-wrangler",
    "text": "For raw data type of applications, it&#x27;s definitely important to be able to preserve pipeline oriented use-cases like `cat img.png | convert-stdin-to-jpg | convert-stdin-back-to-png | imgcat`.  But in the hypothetical world where <i>all</i>  CLI I&#x2F;O moves towards JSON, I&#x27;d still argue this is not only possible but now <i>strictly easier</i> because you can just explicitly embed mimetype info + b64 instead of assuming&#x2F;detecting encoding or requiring user to specify it, or working with heuristic file-magic.  (Jupyter notebooks work like this to persist images instead of just flat text.)  And presumably a smarter suite of JSON oriented tools like jcat&#x2F;jless would either actually display that data, or notice the type and avoid spamming the screen with raw b64.",
    "time": 1762917658
  },
  {
    "type": "comment",
    "by": "robot-wrangler",
    "text": "Emacs user of a highly customized and well-loved setup for over a decade before I gave up the habit ;)  But this illustrates my point perfectly.  That&#x27;s a huge list of stuff that all needs to be turned on or configured in various ways.  Some newbie who is shopping for a new terminal-emulator saw this, gave up immediately, and decided to download kitty because it looks like an app and not a platform.<p>To successfully argue that it&#x27;s just perfect as a terminal emulator, I think you need to find a way to ship it in exactly that configuration.  That would mean that you open it up to a shell prompt with a dollar sign, you can hit ctrl-t to get a new terminal tab.  Clicking URLs should open them in a browser without having to copy&#x2F;paste.  Speaking of copy&#x2F;paste, that should work too, and ctrl-e, and ctrl-a, etc, etc.",
    "time": 1762918487
  },
  {
    "type": "comment",
    "by": "wredcoll",
    "text": "I&#x27;d like to make the distinction between text, indeed, word&#x2F;command based interfaces and &quot;terminal&quot;.<p>It so happens that right now one is synonymous with the other but there&#x27;s no instrinsic requirement.<p>There&#x27;s probably something to be said for the inherent constraints imposed by the terminal protocol, but, again, we can build the same things without that.",
    "time": 1762918878
  },
  {
    "type": "comment",
    "by": "wredcoll",
    "text": "I haven&#x27;t personally implemented one but I&#x27;ll quote someone who has spent a lot more time on it:<p>&gt; Many of these implementations are ad-hoc, one-off solutions. They aren&#x27;t using any shared library or codebase.2 Terminal emulation is a classic problem that appears simple on the surface but is riddled with unexpected complexities and edge cases.3 As a result, most of these implementations are incomplete, buggy, and slow.4 [1]<p>(I mean, it&#x27;s possible html&#x2F;css deserves to be called horrible also but they produce an undeniably superior result)<p>[1] <a href=\"https:&#x2F;&#x2F;mitchellh.com&#x2F;writing&#x2F;libghostty-is-coming\" rel=\"nofollow\">https:&#x2F;&#x2F;mitchellh.com&#x2F;writing&#x2F;libghostty-is-coming</a>",
    "time": 1762919087
  },
  {
    "type": "comment",
    "by": "7e",
    "text": "A terminal will be useful for about twenty more years, not 200. At that point AI agents will take care of low level monkey wrenching for us. It’s like talking about designing a slide rule for the next 200 years.",
    "time": 1762919494
  },
  {
    "type": "comment",
    "by": "skydhash",
    "text": "I think we went past each other at some point. I was not arguing that you can use Emacs as a terminal emulator. I was talking more about terminals and shell being a way of computing. Emacs is an alternate way of computing.<p>With terminals, you have the escapes sequences, the alternate screen, the shell capabilities. With Emacs, you have a lisp VM with a huge library of functions and buffers. I still use a normal terminal like xterm and Terminal.app, but I have eat installed and it&#x27;s working great.",
    "time": 1762919806
  },
  {
    "type": "comment",
    "by": "zzo38computer",
    "text": "That can be helpful, although JSON is still a bad format for this, especially since now it requires base64 encoding. People think JSON is a good format but it isn&#x27;t. (MIME is also not a very good format for identifying file formats, since you can only specify one format; although there is a &quot;added on&quot; specification like &quot;+zip&quot; and &quot;+der&quot; this isn&#x27;t very good.)",
    "time": 1762920219
  },
  {
    "type": "comment",
    "by": "zzo38computer",
    "text": "I do not understand very well what you mean.",
    "time": 1762920344
  },
  {
    "type": "comment",
    "by": "esjeon",
    "text": "I really wish something like Mathematica is available in open source. It is a notebook environment based on a Lisp-like language.<p>Its flexibility is beyond imagination. Programs can emit anything from simple numbers&#x2F;vectors&#x2F;matrices to medias (image, sound, video, either loaded or generated) to interactive programs, all of which can be embedded into the notebook.  You can also manipulate every input and output code blocks programmatically, because it&#x27;s Lisp, and can even programmatically generate notebooks. It can also do typesetting and generate presentation&#x2F;PDF&#x2F;HTML from notebooks.<p>What people have been doing w&#x2F; Markdown and Jupyter in recent years has been available in Mathematica since (at least) 1-2 decades ago. FOSS solutions still fall short, because they rely on static languages (relative to Lisp, of course).<p>I mean, really, it&#x27;s a technological marble. It&#x27;s just that it&#x27;s barred behind an high price tag and limited to low core counts.",
    "time": 1762920740
  },
  {
    "type": "comment",
    "by": "efitz",
    "text": "Why does the successor to the terminal need to be text oriented at all?<p>Maybe it is an API.  Maybe the kernel implements this API and it can be called locally or remotely.  Maybe someone invents an OAuth translation layer to UIDs.  The API allows syscalls or process invocation.  Output is returned in response payload (ofc we have a stream shape too).<p>Maybe in the future your “terminal” is an app that wraps this API, authenticates you to the server with OAuth, and can take whatever shape pleases you- REPL, TUI, browser-ish, DOOM- like (shoot the enemy corresponding to the syscall you want to make), whatever floats your boat.<p>Heresy warning.  Maybe the inputs and outputs don’t look anything like CLI or stdio text.  Maybe we move on from 1000-different DSLs (each CLI’s unique input parameters and output formats) and make inputs and outputs object shaped.  Maybe we make the available set of objects, methods and schemas discoverable in the terminal API.<p>Terminals aren’t a thing of the 80s; they’re a thing of the early 70s when somebody came up with a clever hack to take a mostly dumb device with a CRT and keyboard and hook it to a serial port on a mainframe.<p>Nowadays we don’t need that at all; old-timers like me like it because it’s familiar but it’s all legacy invented for a world that is no longer relevant.   Even boot environments can do better than terminals today.",
    "time": 1762921070
  },
  {
    "type": "comment",
    "by": "mamcx",
    "text": "No, the problem is that the proposal is not enough *bold*.<p>A &quot;barely better&quot; version of something entrenched rarely win (maybe only if the old thing not get updaters).<p>This is the curse of OpenOffice &lt; MS Office.<p>This is in fact the major reason:<p>&gt; Great, now you just need to build and maintain shims for every tool in existence<p>MOST of that tools are very bad at ux! so inconsistent, weird, arcane that yes,  is MADNESS to shim all of them.<p>Instead, if done from first principles, you can collapse <i>thousands</i> of cli arguments, options, switched and such things in few (btw a good example is jj vs git).<p>This is how could be: Adopt an algebra similar to the relational model, and a standardized set of most things millions of little tools have (like the commands help, sort, colors, input&#x2F;output formats, etc) and then suddenly you have a more tractable solution.<p>ONLY when a tool is a total game changer people will switch.<p>And what about all the other stuff? In FoxPro (that in some ways show the idea you just preen `!` and then run the shell command you need. That is enough (editors and such? Much better to redo in the new way, and everyone knows that vim and emacs fan never change ways)",
    "time": 1762921513
  },
  {
    "type": "comment",
    "by": "worthless-trash",
    "text": "Got some news for you, there will be unix and cobol still running in 20 years from now.  No amount of AI will be able to convince bank executives the risk conversion is worth it.",
    "time": 1762921533
  },
  {
    "type": "comment",
    "by": "adzm",
    "text": "Actually a really neat concept with building that into windows terminal. I remember seeing this a while ago. Personally I love the notebook style interactive documents and hope there are more going forward.",
    "time": 1762921612
  },
  {
    "type": "comment",
    "by": "vacuity",
    "text": "I&#x27;d like to make another standard file descriptor to manage the control plane, like stdin&#x2F;stdout&#x2F;stderr, but figuring out which file descriptor it should be is a bit complicated. I&#x27;m wondering if the OS could backwards-compatibly integrate it with stderr in the standard file descriptor at index 2.",
    "time": 1762922689
  },
  {
    "type": "comment",
    "by": "vlovich123",
    "text": "&gt; Heresy warning. Maybe the inputs and outputs don’t look anything like CLI or stdio text. Maybe we move on from 1000-different DSLs (each CLI’s unique input parameters and output formats) and make inputs and outputs object shaped. Maybe we make the available set of objects, methods and schemas discoverable in the terminal API.<p>This is Powershell. It’s a cool idea for sure. One thing I’ve noticed though is that it becomes closer to a programming language and further away from scripting (ie you have to memorize the APIs and object shapes). And at that point, why would you write the program in a worse programming language?<p>By comparison, I’ve noticed even windows-leaning folks do a better job remembering how to delete files and find files than doing so through cmd.exe or powershell. I think that’s because you can run the command to see the output and then you know the text transformation you need to apply for the next step whereas powershell shows you formatted text but objects in the pipe.<p>Maybe a better terminal that provided completion for commands with AI support and a uniform way to observe the object shapes instead of formatted text might mitigate this weakness but it is real today at least imho.",
    "time": 1762922690
  },
  {
    "type": "comment",
    "by": "kamaal",
    "text": "Whatever merit alternatives have, the reality is these make long, like very long migration arcs, these days you will have so much team churn, maintenance rabit holes and regular tech debt and feature requests that its fair enough to say any project that starts to move out of Mainframe tech will never see the finishing line.<p>You are better off maintaining what already works. Either way why do you want to migrate when things are just working fine as is?",
    "time": 1762924420
  },
  {
    "type": "comment",
    "by": "abnercoimbre",
    "text": "Self-plug since you&#x27;re my exact target audience: check out Terminal Click [0]. It&#x27;s still early days though.<p>[0] <a href=\"https:&#x2F;&#x2F;terminal.click\" rel=\"nofollow\">https:&#x2F;&#x2F;terminal.click</a>",
    "time": 1762925762
  },
  {
    "type": "comment",
    "by": "eviks",
    "text": "Let&#x27;s replace it with something useful then, junk isn&#x27;t the only option",
    "time": 1762926657
  },
  {
    "type": "comment",
    "by": "iberator",
    "text": "AMEN Brother.<p>It&#x27;s especially important for retro and embeded computing. Legacy systems as well (banks, telecoms etc)<p>That&#x27;s why most teleco hardware still runs telnet client haha (RRUS AND BBUS) (over IPsec) hehe",
    "time": 1762927109
  },
  {
    "type": "comment",
    "by": "bawolff",
    "text": "&gt; Why does the successor to the terminal need to be text oriented at all?<p>I think because we already have non-text based terminal succesors.<p>I think there is interest in a succesor to text-bassd because a lot of people both like them but the space has been rather stagnant for a while.<p>To put it bluntly, what if its nothing like you ever imagined isn&#x27;t all that interesting as speculation because it doesn&#x27;t commit to any choices. The proposal has to be imaginable to be interesting.",
    "time": 1762927659
  },
  {
    "type": "comment",
    "by": "lynx97",
    "text": "Since you mention Emacs, I&#x27;d like to point to one thing that really only Emacs has, and nothing else: If you implement your &quot;app&quot; with Elisp, it is truly UI independant.  It will work in a terminal, and with a GUI.  To my knowledge, there is no such thing elsewhere.  I used to write a lot of Elisp, roughly 20 years ago.  And I did it all in a terminal, because this is what I <i>can</i> use.  And users of my code could use it in their GUI environment, without even knowing that I was coming from a plain text-mode background.  Again, this is very special, and IMO there is no other &quot;platform&quot; around which can do that.",
    "time": 1762927838
  },
  {
    "type": "comment",
    "by": "eviks",
    "text": "&gt; I&#x27;m not saying that this ecosystem couldn&#x27;t be improved<p>Yes, you effectively are, and the current unstructured buggy mess is &quot;just works&quot; for you.<p>&gt; But it needs broad community discussion, planning, and support,<p>Where was this when all the historic mistakes were made? And why would fixing them suddenly needs to overcome this extra barrier?",
    "time": 1762928364
  },
  {
    "type": "comment",
    "by": "karthink",
    "text": "I think Neovim is more flexible -- a plugin you write for neovim can run in the terminal, in any Neovim GUI or in another application (like VSCode) that can embed Neovim.",
    "time": 1762929349
  },
  {
    "type": "comment",
    "by": "slickytail",
    "text": "As a non Emacs user, I would be really interested in a full writeup of how this works.",
    "time": 1762931212
  },
  {
    "type": "comment",
    "by": "lynx97",
    "text": "I tried to use Neovim several times.  However, it appears to not be very friendly for my usecase, which is using it with a Braille display.  A lot of Neovim UI elements only use background&#x2F;foreground color to indicate highlighted positions, instead of making use of the cursor.  I couldn&#x27;t even use the intial plugin menu.  Emacs is much better in thsi regard.",
    "time": 1762931343
  },
  {
    "type": "comment",
    "by": "zzo38computer",
    "text": "OK, but I don&#x27;t know how you would integrate it with an existing file descriptor. (It is why I suggested using a environment variable to manage this.)",
    "time": 1762932315
  },
  {
    "type": "comment",
    "by": "zombot",
    "text": "I always thought that a terminal should look and behave much like a Mathematica notebook. Imagine my disappointment when I saw my first Unix shell.",
    "time": 1762934051
  },
  {
    "type": "comment",
    "by": "nektro",
    "text": "the terminal of the future is here and it&#x27;s <a href=\"https:&#x2F;&#x2F;github.com&#x2F;ghostty-org&#x2F;ghostty\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;ghostty-org&#x2F;ghostty</a>",
    "time": 1762934695
  },
  {
    "type": "comment",
    "by": "silon42",
    "text": "Yeah... I have no wish to use a terminal with graphics modes.",
    "time": 1762936315
  },
  {
    "type": "comment",
    "by": "skissane",
    "text": "Historically some systems did have more than three standard file descriptors - e.g. for MS-DOS C compilers, a de facto standard was stdprn was your printer and stdaux was a serial port - this was because while Unix by default starts each process with 3 inherited handles, MS-DOS has 5 (CP&#x2F;M influence). NT-based Windows abandoned this<p>But trying to add a fourth now, would likely break too many things; some software will assume any fd &gt; 2 is free for it to clobber.<p>The IBM mainframe operating system z&#x2F;OS (formerly MVS), classically instead of numbers for inherited descriptors, the API uses names (DDNAMEs)-that would have made adding a new one a lot easier. But decades too late for that in Unix land, and eventually MVS added the Unix way too for Unix compatibility-the classic API still uses DDNAMEs, but many apps now use the file descriptor-based z&#x2F;OS Unix API instead",
    "time": 1762936525
  },
  {
    "type": "comment",
    "by": "fergie",
    "text": "Wait. Did Jyn just describe Emacs?",
    "time": 1762937523
  }
]
